generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id               String            @id @db.Uuid
  email            String            @unique
  name             String?
  avatarUrl        String?           @map("avatar_url")
  createdAt        DateTime          @default(now()) @map("created_at")
  updatedAt        DateTime          @updatedAt @map("updated_at")
  calendarAccounts CalendarAccount[]
  meetings         Meeting[]

  @@map("users")
}

model CalendarAccount {
  id                    String   @id @default(uuid()) @db.Uuid
  userId                String   @map("user_id") @db.Uuid
  provider              String   @default("google")
  email                 String
  accessToken           String   @map("access_token")
  refreshToken          String?  @map("refresh_token")
  expiresAt             DateTime @map("expires_at")
  scope                 String
  meetingbaasCalendarId String?  @map("meetingbaas_calendar_id")
  isActive              Boolean  @default(true) @map("is_active")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider, email])
  @@index([meetingbaasCalendarId])
  @@map("calendar_accounts")
}

model Meeting {
  id               String        @id @default(uuid()) @db.Uuid
  userId           String        @map("user_id") @db.Uuid
  botId            String        @unique @map("bot_id")
  botName          String        @map("bot_name")
  meetingUrl       String        @map("meeting_url")
  calendarEventId  String?       @map("calendar_event_id")
  status           String
  recordingMode    String        @default("speaker_view") @map("recording_mode")
  durationSeconds  Int?          @map("duration_seconds")
  participantCount Int?          @map("participant_count")
  // Legacy URL fields (kept for backwards compatibility, expire after 4 hours)
  videoUrl         String?       @map("video_url")
  audioUrl         String?       @map("audio_url")
  transcriptUrl    String?       @map("transcript_url")
  diarizationUrl   String?       @map("diarization_url")
  // Error tracking
  errorCode        String?       @map("error_code")
  errorMessage     String?       @map("error_message")
  endReason        String?       @map("end_reason")
  // Processing status: pending, processing, completed, failed
  processingStatus String?       @map("processing_status")
  // Extra data from MeetingBaas (includes user_id for calendar bots)
  extra            Json?
  // Timestamps
  createdAt        DateTime      @default(now()) @map("created_at")
  updatedAt        DateTime      @updatedAt @map("updated_at")
  completedAt      DateTime?     @map("completed_at")
  // Relations
  actionItems      ActionItem[]
  user             User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  participants     Participant[]
  summary          Summary?
  transcript       Transcript?
  diarization      Diarization?

  @@index([userId, createdAt])
  @@index([status])
  @@index([calendarEventId])
  @@index([status, createdAt(sort: Desc)])
  @@index([processingStatus])
  @@map("meetings")
}

model Transcript {
  id        String   @id @default(uuid()) @db.Uuid
  meetingId String   @unique @map("meeting_id") @db.Uuid
  data      Json     // Processed utterances array
  rawData   Json?    @map("raw_data") // Raw Gladia response (includes summaries, translations, etc.)
  createdAt DateTime @default(now()) @map("created_at")
  meeting   Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  @@map("transcripts")
}

model Diarization {
  id        String   @id @default(uuid()) @db.Uuid
  meetingId String   @unique @map("meeting_id") @db.Uuid
  data      Json     // Speaker identification data with timestamps
  createdAt DateTime @default(now()) @map("created_at")
  meeting   Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  @@map("diarizations")
}

model Summary {
  id        String   @id @default(uuid()) @db.Uuid
  meetingId String   @unique @map("meeting_id") @db.Uuid
  overview  String
  keyPoints String[] @map("key_points")
  decisions String[]
  nextSteps String[] @map("next_steps")
  createdAt DateTime @default(now()) @map("created_at")
  meeting   Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  @@map("summaries")
}

model ActionItem {
  id          String   @id @default(uuid()) @db.Uuid
  meetingId   String   @map("meeting_id") @db.Uuid
  description String
  assignee    String?
  dueDate     String?  @map("due_date")
  completed   Boolean  @default(false)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  meeting     Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  @@index([meetingId])
  @@map("action_items")
}

model Participant {
  id        String    @id @default(uuid()) @db.Uuid
  meetingId String    @map("meeting_id") @db.Uuid
  name      String
  email     String?
  role      String?
  joinedAt  DateTime? @map("joined_at")
  leftAt    DateTime? @map("left_at")
  meeting   Meeting   @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  @@index([meetingId])
  @@map("participants")
}

model CalendarEvent {
  id            String   @id @default(uuid()) @db.Uuid
  eventId       String   @unique @map("event_id")
  calendarId    String   @map("calendar_id")
  title         String
  startTime     DateTime @map("start_time")
  endTime       DateTime @map("end_time")
  meetingUrl    String?  @map("meeting_url")
  platform      String?
  botScheduled  Boolean  @default(false) @map("bot_scheduled")
  rawData       Json     @map("raw_data")
  lastFetchedAt DateTime @default(now()) @map("last_fetched_at")

  @@index([calendarId])
  @@map("calendar_events")
}
